# 线性表

1.  [线性表的定义和基本操作](#线性表的定义和基本操作)
2.  [线性表的实现](#线性表的实现)
3.  [线性表的应用](#线性表的应用)

## 线性表的定义和基本操作

线性表是具有相同类型的n（n>=0）个元素的有限序列，其中n为表长，当n=0时，该表为空表。

当L命名为线性表，则一般表示为：L = (a<sub>1</sub>,a<sub>2</sub>,...,a<sub>i</sub>,a<sub>i+1</sub>,...,a<sub>n</sub>)。

*   表中，第一个元素，称为表头元素，最后一个元素称为表尾元素。
*   在线性表中，每个元素除了表头元素，它都有一个前驱结点。同样在表中，每一个元素除了表尾元素，它都有一个后继结点。
*   线性表的特点：
    *   表中元素个数有限。
    *   表中元素具有逻辑上的顺序性，在序列中各个元素排序有其先后次序。
    *   表中元素都是数据元素，每个元素都是单个元素。
    *   表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
    *   表中元素具有抽象性，即讨论元素间一对一的逻辑关系，而不考虑元素究竟表示的内容。
    *   线性表是一种逻辑结构，表示元素之间一对一相邻的关系。

## 线性表的实现

顺序存储：

*   线性表的顺序存储又称为顺序表。一组地址连续存放的存储单元依次存放线性表的元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。所以有这样的规律：顺序表中逻辑顺序和物理顺序相同。
*   静态分配和动态分配：

    ```c
    /* 静态分配 */
    #define MaxSize 50
    typedef struct {
      ElemType data[MaxSize];
      int length;
    } SqList;
    ```

    ```c
    /* 动态分配 */
    #define MaxSize 50
    typedef struct {
      ElemType *data;
      int length;
    } SqList;
    L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);  // c
    L.data = new ElemType[InitSize];                        // c++
    ```

链式存储：

*   单链表：
    *   单链表通过一组任意的存储单元来存储线性表中的数据元素，也就是数据元素的位置不一定连续。
    *   单链表通过指针来实现线性的逻辑关系的，它与顺序存储是不同的。
    *   引入头结点：
        *   第一个优点是链表的第一个位置和其他位置的操作进行统一了。
        *   第二个优点是空表和非空表的操作统一了。
        *   在引入头结点之后，许多东西都发生变化了，其中一个就是如何判断单链表是个空表。如果没有头结点的单链表，判断它为空的办法为头指针是否为空，如果头指针为空，那么单链表就是空。如果有头结点的单链表，判断它为空的办法为头结点的next域是否为空，如果head->next为空，那么单链表就是空。
        *   记住引入头结点之后，第一个数据元素依旧是头结点的next域指向的那个结点，而非头结点。
*   双向链表：
    *   同单链表相比，双链表仅是各结点多一个用于指向直接前驱的指针域。需要注意的是，双链表创建过程中，每创建一个新结点，都要与前驱结点建立两次联系，分别是：
        *   将新结点的prior指针指向直接前驱结点。
        *   将直接前驱结点的next指针指向新结点。
    *   双向链表相对于单链表来说，要复杂些，多了个直接前驱指针，对于添加、删除操作需要考虑的指针交换需要格外小心。而且占用空间也增加了。但是它有良好的对称性，是对于某个结点的前后结点的操作，带来了方便，提高了算法时间性能，也就是使用空间来换取时间。
*   循环链表：
    *   将单链表中终端结点的指针端有空指针改为指向头结点，使得整个单链表形成一个环，这种头尾相接的单链表称为单循环链表。双循环链表同理。
    *   优点是无论从链表的哪一个结点出发，都可以访问到所有的结点。
    *   约瑟夫问题。

静态链表：

*   静态链表相当于是用一个数组来实现线性表的存储结构。
*   数组中的每个分量是链表中一个结点。每个结点包含两个域，一个是数据域（data），用来存放数据元素；一个是游标域（cursor），代替动态指针指示其直接后继在数组中的相对位置。

```c
typedef struct LNode {
  ElemType data;
  struct LNode *next;
} LNode, *LinkList;
```

```c
typedef struct DLNode {
  struct DLNode *prior;
  ElemType data;
  struct DLNode *next;
} DLNode, *DLinkList;
```

复杂度分析：

*   时间复杂度：
    *   链式存储按位查找的性能为O(n)，而顺序存储为O(1)。
    *   链式存储的插入和删除操作，在计算出某位置的指针后，插入和删除的性能为O(1)，而顺序存储结构为O(n)。
    *   单链表寻找某个结点的前一个结点的时间复杂度为O(n)，使用双向链表去查找前一个结点的时间复杂的为O(1)。
*   空间复杂度：
    *   顺序存储结构需要预分配存储空间。
    *   链式存储结构不需要分配存储空间，元素限制不受控制。
*   经验总结：
    *   当线性表需要频繁查找，很少进行插入和删除操作，应该选择顺序存储结构。
    *   当线性表中元素个数变化较大或根本不知道有多大时，最好使用单链表结构，不需要考虑存储空间大小问题。

## 线性表的应用

顺序存储：

*   src/seq_list

链式存储：

*   src/link_list
