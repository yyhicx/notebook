# 入门

1.  [UNIX、Linux和GNU简介](#unixlinux和gnu简介)
2.  [Linux程序设计](#linux程序设计)
3.  [帮助命令](#帮助命令)

## UNIX、Linux和GNU简介

Linux的成功归功于在它之前诞生的系统和应用程序--Unix和GNU软件。

什么是UNIX：

*   UNIX操作系统最初是贝尔实验室开发的，当时的贝尔实验室是电信业巨头AT&T旗下的一员。严格来说，UNIX是由Open Group管理的一个商标，它指的是一种遵循特定规范的计算机操作系统。这个规范也称为单一UNIX规范，它定义了所有必须的UNIX操作系统函数的名称、接口和行为。这个规范在很大程度上是早期由IEEE开发的P1003或POSIX规范的超集。
*   UNIX哲学（Unix程序设计风格，同样也是Linux程序设计风格）：
    *   简单性：许多很有用的UNIX工具是非常简单的，因此也是很小并易于理解的。“小而简单”（KISS：Keep It Small and Simple）是一种值得学习的技术。越大、越复杂的系统注定包含很大、越复杂的错误，而调试是我们所有人都想避免的苦差事。
    *   集中性：通常，让一个程序很好地执行一项任务要过把所有功能都乱七八糟地堆在一起。功能臃肿地程序难以使用和维护，只有单一目标的程序更容易随着更好的算法或界面被开发出来而得到改进。在UNIX中，当用户出现新的需求时，通常我们是把小工具组合起来以完成更负责的任务，而不是试图将一个用户的期望的所有功能放在一个大程序里。
    *   可重用组件：将应用程序的核心实现为库。具有简单而灵活的编程接口、文档齐备的库可以帮助其他人开发出同类程序，或者把这些技术应用到新的应用领域。dbm库就是一个例子，它是一组可重用的函数，而不是单一的数据库管理程序。
    *   过滤器：许多UNIX应用程序可用作过滤器。也就是说，它们对输入进行转换并产生输出。正如你将在后面看到的，UNIX提供了一些机制，让我们可以把一些UNIX程序通过一种新颖的方式组合起来，以开发出相当负责的应用程序。当然，这种类型的重用是靠我们前面提到的开发方法支撑的。
    *   开放的文件格式：比较成功并流行的UNIX程序都使用纯ASCII码文本文件或XML文件作为配置文件和数据文件。如果你在开发程序时采用了任一种做法，那你做对了！它使用户可以用标准工具来修改和搜索配置项，并且可以开发出新工具在数据文件上执行新功能。ctags源代码交叉引用系统就是一个好例子，它把符号信息以适用于搜索程序使用的正则表达式的形式记录下来。
    *   灵活性：你不能期待用户都能正确地使用你的程序。所以，你在编程时应尽量考虑到灵活性，尽量避免随意限制字段长度或记录数目。如果你能做到的话，则你编写的网络程序既能在单机上运行，也能跨网络运行。永远不要认为你知道用户想做的一切事。

什么是Linux：

*   Linux是Linus Torvalds开发的，期间得到了互联网上广大UNIX程序员的帮助。
*   Linux是一个可以自由发布的类UNIX内核实现，它是一个操作系统的底层核心。
*   [The Linux Kernel Archives](https://www.kernel.org)
  
GNU项目和自由软件基金会：

*   Linux社区支持自由软件的概念，即软件本身不应受限，它们应遵守GNU通用公开许可证（GPL）。
*   自由软件基金会（Free Software Foundation）由Richard Stallman创立，他是自由软件这一概念的倡导者，并发起了GNU项目，这个项目的宗旨是：试图创建一个与UNIX系统兼容，但并不受UNIX名字和源代码私有权限制的操作系统和开发环境。
*   下面是在GPL条款下发布的一些主要的GNU项目软件：
    *   `GCC`：GNU编译器集，它包括GNU C编译器。
    *   `G++`：C++编译器，是GCC的一部分。
    *   `GDB`：源代码级的调试器。
    *   `GNU make`：UNIX make命令的免费版本。
    *   `bash`：命令解释器。
    *   `GNU Emacs`：文本编辑器及环境。
*   [GNU's Not UNIX](https://www.gnu.org)
*   Copyright和Copyleft：
    *   Copyright：版权所有，即软件的一切权利归软件作者私有。
    *   Copyleft：反对软件一切权利归作者私有，保护知识共享、权利共享。

Linux发行版：[Distro Watch](https://www.distrowatch.com)

## Linux程序设计

Linux程序：

*   Linux应用程序表现为两种特殊类型的文件：可执行文件和脚本文件。可执行文件是计算机可以直接运行的程序；脚本文件是一组指令的集合，这些指令将由另一个程序（即解释器）来执行。
*   当登录Linux系统时，你与一个shell程序进行交互。它在一组指定的目录路径下按照你给出的程序名搜索与之相同的文件。搜索的目录路径存储在shell变量PATH里。搜索路径由系统管理员配置，它通常包含如下一些存储系统程序的标准路径：
    *   /bin：二进制文件目录，用于存放启动系统时用到的程序。
    *   /usr/bin：用户二进制文件目录，用于存放用户使用的标准程序。
    *   /usr/local/bin：本地二进制文件目录，用于存放软件安装的程序。
    *   /sbin和/usr/sbin：系统管理员登陆后使用PATH变量可能还包含系统管理程序的目录。
    *   /opt：可选的操作系统组件和第三方应用程序。

开发系统引导（了解软件工具和开发资源在系统中存放的位置）：
  
*   应用程序：
    *   系统为正常使用提供的程序，包括用于程序开发的工具，都可在目录/usr/bin中找到。
    *   系统管理员为某个特定的主机或本地网络添加的程序通常在目录/usr/local/bin或/opt中找到。
*   头文件：用C语言及其他语言进行程序设计时，你需要用头文件来提供对常量的定义和对系统函数及库函数调用的声明。
    *   对于C语言来说，这些头文件几乎总是位于/usr/include目录及其子目录中。
    *   那些依赖特定linux版本的头文件通常可在目录/usr/include/sys和/usr/include/linux中找到。
    *   其他编程系统也有各自的头文件，这些头文件被存储在可被相应编译器自动搜索到的目录里。例如，X视窗系统的/usr/include/X11目录和GNU C++的/usr/include/c++目录。

    ```bash
    # gcc 使用 -I 标志来包含保存在子目录或非标准位置中的头文件
    gcc -I /usr/openwin/include fred.c
    ```

    ```bash
    # 使用 grep 命令来搜索包含某些特定定义和函数原型的头文件是很方便的
    grep EXIT_ *.h
    ```

*   库文件：库是一组预先编译好的函数的集合，这些函数都是按照可重用的原则编写的。它们通常由一组相互关联的函数组成以执行某项常见的任务。
    *   标准系统库文件一般存储在/lib和/usr/lib目录中，默认情况下，C语言链接器只搜索标准库。
    *   使用非标准库内库文件：库文件必须遵循特定的命名规范并且需要在命令行中明确制定存储位置。
    *   库文件的命名规范：名字总是以lib开头，随后的部分指明这是什么库（例如，c代表C语言库，m代表数学库），文件名的最后部分以.开始。.a代表传统的静态函数库，.so代表共享函数库，函数库通常以静态库和共享库两种格式存在。

    ```bash
    # 使用完成的库文件路径名，告诉编译器要搜索的库文件
    gcc -o fred fred.c /usr/lib/libm.a
    ```

    ```bash
    # 使用 -l 标志来告诉编译器要搜索的库文件
    # -lm 是一种简写方式，它代表的是标准库目录中名为 libm.a 的函数库
    gcc -o fred fred.c -lm
    ```

    ```bash
    # 使用 -L 标志为编译器增加库的搜索路径
    # 这条命令用 /usr/openwin/lib 目录下的 libX11 库版本来编译和链接程序 x11fred
    gcc -o x11fred -L /usr/openwin/lib x11fred.c -lX11
    ```

*   静态库：函数库最简单的一组处于“准备好使用”状态的目标文件。当程序需要使用函数库中的某个函数时，它包含一个声明该函数的头文件。编译器和链接器负责将程序代码和函数库结合在一起以组成一个单独的可执行文件。
    *   你必须使用-l选项来指明除标准C语言运行库外还需使用的库。
    *   静态库也称为归档文件(archive)，按惯例它们的文件名都以.a结尾。
    *   使用ar程序和gcc -c命令对函数分别进行编译，即可创建和维护自己的静态库：
        1.  编写fred函数和bill函数，并分别写入fred.c和bill.c源文件：

            ```c
            // fred.c
            # include <stdio.h>
            void fred(int arg) {
              printf("fred: we passed %d\n", arg);
            }
            ```

            ```c
            // bill.c
            # include <stdio.h>
            void fred(char *arg) {
              printf("bill: we passed %s\n", arg);
            }
            ```

        2.  编译bill.c和fred.c文件成bill.o和fred.o：

            ```bash
            gcc -c bill.c fred.c
            ```

        3.  编写lib.h头文件（包含fred函数和bill函数的声明）：

            ```c
            void bill(char *);
            void fred(int);
            ```

        4.  编写program.c源文件（包含main函数）：

            ```c
            #include <stdlib.h>
            #include "lib.h"

            int main() {
              bill("Hello World");
              fred(1024);
              exit(0);
            }
            ```

        5.  编译program.c文件成program.o：

            ```bash
            gcc -c program.c
            ```

        6.  生成program：
            *   不使用静态库：

                ```bash
                gcc -o program program.o bill.o fred.o
                ```

            *   使用静态库：

                ```bash
                ar crv libfoo.a bill.o fred.o  # 创建库文件
                ranlib libfoo.a  # 不是必须
                ```

                ```bash
                # 两个生成命令二选一
                gcc -o program program.o libfoo.a
                gcc -o program program.o -L. -lfoo  # -L. 选项告诉编译器在当前目录中查找函数库
                ```

    *   可以使用nm命令查看程序中包含了什么函数。
*   共享库：
    *   静态库的一个缺点：当你同时运行许多应用程序并且它们都使用来自同一个函数库的函数时，内存中就会有同一函数的多份副本，而且在程序文件自身中也有多份同样的副本。这将消耗大量宝贵的内存和磁盘空间。
    *   使用共享库时，程序本身不再包含函数代码，而是引用运行时可访问的共享代码。当编译好的程序被装载到内存中执行时，函数引用被解析并产生对共享库的调用，如果有必要，共享库才被加载到内存中。
    *   共享库的保存位置与静态库是一样的标准数学库的共享版本是/usr/lib/libm.so。
    *   动态装载器：对Linux系统来说，负责装载共享库并解析客户程序函数引用的程序是ld.so。
    *   生成program（使用共享库）：

        ```bash
        gcc -fPIC -shared -o libfoo.so bill.o fred.o
        gcc -o program program.o -L. -lfoo
        ```

    *   Linux系统中用ldd命令查看程序需要什么共享库，Macos系统中用otool -L查看。

## 帮助命令

绝大多数Linux系统都为系统编程接口和标准工具提供了很好的文档：

*   man：

    ```bash
    man gcc
    ```

*   info：

    ```bash
    info gcc
    ```
