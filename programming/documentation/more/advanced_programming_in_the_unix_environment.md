# UNIX环境高级编程

## UNIX基础知识

UNIX系统：

*   UNIX内核：内核是操作系统的核心，它控制着系统的各种资源和操作。
*   UNIX内核的接口称之为系统调用。公用函数库构建在系统调用接口之上，为应用程序提供了更高层次的抽象和更丰富的功能。应用程序既可以使用公用函数库，也可以使用系统调用。
*   UNIX Shell是用户与内核之间的接口。它提供了命令行接口，让用户能够通过键入命令来控制系统。
*   路径名由斜杠（`/`）分割的一个或者多个文件名组成的序列：
    *   绝对路径：以斜杠开头，表示从根目录开始的路径。
    *   相对路径：以非斜杠开头，表示从当前目录开始的路径。
*   `man`命令：是UNIX系统中广泛使用的一个命令行工具，用于访问系统命令、编程语言、函数库等的参考手册。提供了关于系统命令和程序使用的详细说明、选项、参数、示例等信息。

    ```bash
    man ls  // 查看 ls 命令的手册
    ```

*   UNIX系统中，每个进程都有一个工作目录，它是进程执行文件操作时使用的默认目录，除非在文件操作中明确指定了其他目录（如`chdir()`函数）。当你启动一个程序或命令时，它通常会继承其父进程的工作目录为自己的初始工作目录。所有的相对路径名都是从工作目录开始解释的。
*   UNIX系统中，每个进程都有一个唯一的进程ID（PID），它是系统中每个进程的唯一标识符。

    ```bash
    ps aux  // 查看系统中所有进程的详细信息
    ```

*   通常一个进程只有一个线程，但是你也可以创建多个线程来执行同一个进程中的不同任务。
    *   一个进程内的所有线程共享同一个地址空间、文件描述符、栈、全局变量等资源。
    *   多线程的程序需要在各线程访问共享数据时采取措施来避免不一致性。
    *   线程也有ID（TID），但是线程ID只有在它所属进程内才有意义。
*   用户和组：
    *   用户ID（UID）：是系统中每个用户的唯一标识符。用户ID为0的用户为根用户（即`root`），具有超级用户权限。
    *   组ID（GID）：用户所属的组的唯一标识符。
    *   附属组ID（SGID）：一个用户可以属于多个组，这些组就是附属组。由附属组的ID来标识。
    *   注意：主要组是创建用户时由系统自动分配的，附属组是用户可以加入的其他组。用户通过属于不同的组来共享资源和访问权限。这种机制有助于实现资源的有效管理和权限的灵活控制。

错误处理：

*   UNIX系统中，许多系统调用和某些库函数（例如C标准库）在出错时会返回一个负值，并且会设置全局变量`errno`来指示具体的错误原因。
    *   文件`<errno.h>`是C语言标准库中的一个头文件，它定义了全局变量`errno`，用于存储最近一次系统调用或库函数失败时产生的错误代码。同时还定义了一系列以`E`开头的宏，这些宏代表不同的错误代码。
    *   在多线程环境下，每个线程都有属于自己局部的`errno`变量，以避免一个线程干扰另一个线程。
    *   在使用`errno`时需要注意的是：
        *   如果没有出错，则`errno`的值不会被修改。因此只有在函数的返回值指明出错时，检查`errno`才有意义。
        *   任何函数都不会将`errno`的值清零，并且`<errno.h>`中定义的所有常量都不为0。
*   处理错误信息：
    *   `strerror`：将错误代码映射为一个出错消息字符串，并且返回此字符串的指针。
    *   `perror`：基于`errno`当前值，在标准错误上产生一条出错信息。

    ```c
    #include <errno.h>
    #include <stdio.h>   // 引入 perror
    #include <string.h>  // 引入 strerror

    int main() {
      // 手动设置错误，ENOENT 表示文件不存在
      errno = ENOENT;

      // 输出：`Error: No such file or directory`
      printf("Error: %s\n", strerror(errno));

      // 输出：`File does not exist: No such file or directory`
      perror("File does not exist");

      return 0;
    }
    ```

*   出错恢复：
    *   可以将`<errno.h>`中定义的错误分为两类：
        *   致命性错误：此类错误无法恢复。最多只能再屏幕上打印一条出错信息或者将出错信息写入日志，然后终止程序。
        *   非致命性错误：此类错误可以妥善处理。大多数非致命性错误都是暂时的（比如资源短缺），可以尝试重试，直到成功为止。与资源相关的非致命性错误包括：`EAGAIN`、`ENFILE`、`ENOBUFS`、`ENOLCK`、`ENOSPC`、`EWOULDBLOCK`等。

    ```c
    #include <errno.h>
    #include <stdio.h>
    #include <unistd.h>

    #define MAX_RETRIES 5

    int ReadFromSocket(int sockfd, char *buffer, size_t len) {
      int retries = 0;
      ssize_t bytes_read;

      while (retries < MAX_RETRIES) {
        bytes_read = read(sockfd, buffer, len);

        if (bytes_read == -1) {
          // 检查是否为 EAGAIN 错误
          if (errno == EAGAIN) {
            usleep(100000);  // 等待 100 毫秒
            retries++;
            continue;
          } else {
            perror("read");
            return -1;
          }
        } else if (bytes_read == 0) {
          // 读取到文件结束
          break;
        } else {
          // 读取到数据
          break;
        }
      }

      if (retries == MAX_RETRIES) {
        fprintf(stderr, "Failed to read from socket after %d retries\n", MAX_RETRIES);
        return -1;
      }

      return (int)bytes_read;
    }
    ```

时间：

*   UNIX系统使用两种时间：
    *   日历时间：自UTC1970年1月1日午夜（零时）以来经历过的秒数的累计值。用`time_t`数据类型来保存这种时间值。
    *   进程时间：也称为CPU时间，是指从进程启动到当前所经历的秒数。用`clock_t`数据类型来保存这种时间值。
*   当度量一个进程的执行时间时，UNIX系统为一个进程维护了三个进程时间值：
    *   实际时间：是进程从开始执行到完成所经过的实际时间。这个时间包括了所有等待输入/输出操作的时间，以及由于多任务、上下文切换等原因造成的CPU时间消耗。
    *   用户CPU时间：在用户态下所消耗的CPU时间，主要是执行用户指令的时间。
    *   系统CPU时间：在内核态下所消耗的CPU时间，主要是执行系统中断和系统调用等内核操作的时间。

    ```bash
    time ls  // ls会列出当前目录下的文件，并输出执行时间
    ```

## UNIX标准及实现

UNIX标准：

*   `ISO C`：意图是提供C程序的可移植性，使得它能够适合大量不同的操作系统。该标准不仅定义了C程序设计语言的语法和语义，还定义了标准库。
*   `POSIX`：指的是可移植操作系统接口（Portable Operating System Interface，缩写为POSIX），它是一系列标准的API，旨在为应用程序开发者提供一致的接口，使得应用程序在各种UNIX系统上都能正常运行。`POSIX`包含了`ISO C`标准库函数。
*   `SUS`：是POSIX标准的一个超集，它定义了一些附加接口，扩展了POSIX规范提供的功能。
*   上述三个标准知识定义了接口的规范，而具体实现由产商来完成。目前UNIX主要有以下的实现：
    *   SVR4：由贝尔实验室开发，是最早的UNIX版本。
    *   4.4 BSD：由加州大学伯克利分校开发，是BSD的分支版本。
    *   FreeBSD：基于BSD操作系统。
    *   Linux：由Linus Torvalds开发，是目前最流行的UNIX版本。
    *   Mac OS X：由苹果公司开发，是基于BSD的操作系统。
    *   Solaris：由Oracle公司开发，是基于SunOS的操作系统。

限制：

*   UNIX系统实现定义了很多魔数（magic number）和常量。有两种类型的限制是必须的：
    *   编译时限制，如`short int`最大值是多少。
    *   运行时限制，如文件名最长多少个字符。
*   通常编译时限制可以在头文件中定义（通过宏来实现）；运行时限制可以通过进程调用一个函数获得限制值（通过系统调用来实现）。
*   某些限制在一个给定的UNIX实现中可能是固定的（由头文件定义），在另一个UNIX实现中可能是动态的（需要由进程调用一个函数获得限制值）。如文件名的最大字符数在不同的操作系统中，是属于动态/静态限制。因此提供了三种限制：
    *   编译时限制（头文件）。
    *   与文件或者目录无关的运行时限制（`sysconf`函数）。
    *   与文件或者目录相关的运行时限制（`pathconf`和`fpathconf`函数）。

## POSIX标准库

POSIX标准定义了一系列头文件，这些头文件为应用程序提供了统一的操作系统接口，以实现源代码级别的可移植性。POSIX标准库的头文件主要分为三类：

*   必需头文件：所有遵循POSIX标准的系统都应该提供这些头文件。
    *   `<aio.h>`：异步I/O，提供了异步输入/输出的功能。
    *   `<cpio.h>`：cpio归档值，用于处理cpio归档文件。
    *   `<dirent.h>`：目录项，用于目录操作。
    *   `<dlfcn.h>`：动态链接，提供了动态加载和卸载共享库的功能。
    *   `<fcntl.h>`：文件控制，提供了对文件描述符操作的函数，如打开、锁定等。
    *   `<grp.h>`：组文件，提供了对组信息的访问。
    *   `<iconv.h>`：代码集转换实用程序，用于字符集之间的转换。
    *   `<langinfo.h>`：语言信息常量，提供了与本地化相关的常量。
    *   `<netdb.h>`：网络数据库操作，用于网络编程中解析网络地址和名称。
    *   `<pthread.h>`：线程，提供了线程编程的接口。
    *   `<pwd.h>`：口令文件，提供了对用户信息的访问。
    *   `<sched.h>`：执行调度，提供了与进程调度相关的函数和宏。
    *   `<semaphore.h>`：信号量，提供了POSIX信号量的定义和函数。
    *   `<sys/stat.h>`：文件状态，提供了文件属性相关的数据结构和函数。
    *   `<sys/types.h>`：基本系统数据类型，定义了一系列系统编程中常用的类型。
    *   `<unistd.h>`：符号常量，提供了对POSIX操作系统API的访问，包括文件I/O、进程控制等函数。
*   XSI扩展头文件：
    *   `<fmtmsg.h>`：消息显示结构，用于格式化并显示信息。
    *   `<ftw.h>`：文件树漫游，提供了遍历文件树的函数。
    *   `<sys/ipc.h>`/`<sys/msg.h>`/`<sys/sem.h>`/`<sys/shm.h>`：这些头文件与进程间通信（IPC）相关，分别提供了消息队列、信号量、共享内存等机制的定义和函数。
*   可选头文件：
    *   `<mqueue.h>`：消息队列，提供了POSIX消息队列的定义和函数。
    *   `<spawn.h>`：进程创建，提供了创建新进程的函数。
